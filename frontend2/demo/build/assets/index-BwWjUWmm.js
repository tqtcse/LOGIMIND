import{a7 as se,r as w,R as Dt}from"./index-DtwSxASm.js";var ut={exports:{}},lt={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Wt;function re(){if(Wt)return lt;Wt=1;var t=se();function e(a,l){return a===l&&(a!==0||1/a===1/l)||a!==a&&l!==l}var n=typeof Object.is=="function"?Object.is:e,s=t.useState,c=t.useEffect,r=t.useLayoutEffect,i=t.useDebugValue;function h(a,l){var f=l(),C=s({inst:{value:f,getSnapshot:l}}),d=C[0].inst,q=C[1];return r(function(){d.value=f,d.getSnapshot=l,p(d)&&q({inst:d})},[a,f,l]),c(function(){return p(d)&&q({inst:d}),a(function(){p(d)&&q({inst:d})})},[a]),i(f),f}function p(a){var l=a.getSnapshot;a=a.value;try{var f=l();return!n(a,f)}catch{return!0}}function y(a,l){return l()}var v=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?y:h;return lt.useSyncExternalStore=t.useSyncExternalStore!==void 0?t.useSyncExternalStore:v,lt}var Pt;function oe(){return Pt||(Pt=1,ut.exports=re()),ut.exports}var ie=oe(),qt=Object.prototype.hasOwnProperty;function St(t,e){var n,s;if(t===e)return!0;if(t&&e&&(n=t.constructor)===e.constructor){if(n===Date)return t.getTime()===e.getTime();if(n===RegExp)return t.toString()===e.toString();if(n===Array){if((s=t.length)===e.length)for(;s--&&St(t[s],e[s]););return s===-1}if(!n||typeof t=="object"){s=0;for(n in t)if(qt.call(t,n)&&++s&&!qt.call(e,n)||!(n in e)||!St(t[n],e[n]))return!1;return Object.keys(e).length===s}}return t!==t&&e!==e}const U=new WeakMap,W=()=>{},D=W(),mt=Object,u=t=>t===D,N=t=>typeof t=="function",P=(t,e)=>({...t,...e}),kt=t=>N(t.then),ft={},rt={},Ct="undefined",it=typeof window!=Ct,vt=typeof document!=Ct,ae=()=>it&&typeof window.requestAnimationFrame!=Ct,zt=(t,e)=>{const n=U.get(t);return[()=>!u(e)&&t.get(e)||ft,s=>{if(!u(e)){const c=t.get(e);e in rt||(rt[e]=c),n[5](e,P(c,s),c||ft)}},n[6],()=>!u(e)&&e in rt?rt[e]:!u(e)&&t.get(e)||ft]};let Tt=!0;const ce=()=>Tt,[_t,gt]=it&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[W,W],ue=()=>{const t=vt&&document.visibilityState;return u(t)||t!=="hidden"},le=t=>(vt&&document.addEventListener("visibilitychange",t),_t("focus",t),()=>{vt&&document.removeEventListener("visibilitychange",t),gt("focus",t)}),fe=t=>{const e=()=>{Tt=!0,t()},n=()=>{Tt=!1};return _t("online",e),_t("offline",n),()=>{gt("online",e),gt("offline",n)}},de={isOnline:ce,isVisible:ue},Ee={initFocus:le,initReconnect:fe},jt=!Dt.useId,Z=!it||"Deno"in globalThis,Re=t=>ae()?window.requestAnimationFrame(t):setTimeout(t,1),dt=Z?w.useEffect:w.useLayoutEffect,Et=typeof navigator<"u"&&navigator.connection,Ht=!Z&&Et&&(["slow-2g","2g"].includes(Et.effectiveType)||Et.saveData),ot=new WeakMap,Rt=(t,e)=>mt.prototype.toString.call(t)===`[object ${e}]`;let he=0;const wt=t=>{const e=typeof t,n=Rt(t,"Date"),s=Rt(t,"RegExp"),c=Rt(t,"Object");let r,i;if(mt(t)===t&&!n&&!s){if(r=ot.get(t),r)return r;if(r=++he+"~",ot.set(t,r),Array.isArray(t)){for(r="@",i=0;i<t.length;i++)r+=wt(t[i])+",";ot.set(t,r)}if(c){r="#";const h=mt.keys(t).sort();for(;!u(i=h.pop());)u(t[i])||(r+=i+":"+wt(t[i])+",");ot.set(t,r)}}else r=n?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return r},yt=t=>{if(N(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?wt(t):"",[t,e]};let pe=0;const Ot=()=>++pe,Bt=0,Gt=1,Jt=2,Se=3;var Q={__proto__:null,ERROR_REVALIDATE_EVENT:Se,FOCUS_EVENT:Bt,MUTATE_EVENT:Jt,RECONNECT_EVENT:Gt};async function Kt(...t){const[e,n,s,c]=t,r=P({populateCache:!0,throwOnError:!0},typeof c=="boolean"?{revalidate:c}:c||{});let i=r.populateCache;const h=r.rollbackOnError;let p=r.optimisticData;const y=l=>typeof h=="function"?h(l):h!==!1,v=r.throwOnError;if(N(n)){const l=n,f=[],C=e.keys();for(const d of C)!/^\$(inf|sub)\$/.test(d)&&l(e.get(d)._k)&&f.push(d);return Promise.all(f.map(a))}return a(n);async function a(l){const[f]=yt(l);if(!f)return;const[C,d]=zt(e,f),[q,o,tt,Y]=U.get(e),M=()=>{const I=q[f];return(N(r.revalidate)?r.revalidate(C().data,l):r.revalidate!==!1)&&(delete tt[f],delete Y[f],I&&I[0])?I[0](Jt).then(()=>C().data):C().data};if(t.length<3)return M();let _=s,A;const H=Ot();o[f]=[H,0];const m=!u(p),$=C(),L=$.data,k=$._c,j=u(k)?L:k;if(m&&(p=N(p)?p(j,L):p,d({data:p,_c:j})),N(_))try{_=_(j)}catch(I){A=I}if(_&&kt(_))if(_=await _.catch(I=>{A=I}),H!==o[f][0]){if(A)throw A;return _}else A&&m&&y(A)&&(i=!0,d({data:j,_c:D}));if(i&&!A)if(N(i)){const I=i(_,j);d({data:I,error:D,_c:D})}else d({data:_,error:D,_c:D});if(o[f][1]=Ot(),Promise.resolve(M()).then(()=>{d({_c:D})}),A){if(v)throw A;return}return _}}const $t=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},me=(t,e)=>{if(!U.has(t)){const n=P(Ee,e),s={},c=Kt.bind(D,t);let r=W;const i={},h=(v,a)=>{const l=i[v]||[];return i[v]=l,l.push(a),()=>l.splice(l.indexOf(a),1)},p=(v,a,l)=>{t.set(v,a);const f=i[v];if(f)for(const C of f)C(a,l)},y=()=>{if(!U.has(t)&&(U.set(t,[s,{},{},{},c,p,h]),!Z)){const v=n.initFocus(setTimeout.bind(D,$t.bind(D,s,Bt))),a=n.initReconnect(setTimeout.bind(D,$t.bind(D,s,Gt)));r=()=>{v&&v(),a&&a(),U.delete(t)}}};return y(),[t,c,y,r]}return[t,U.get(t)[4]]},ve=(t,e,n,s,c)=>{const r=n.errorRetryCount,i=c.retryCount,h=~~((Math.random()+.5)*(1<<(i<8?i:8)))*n.errorRetryInterval;!u(r)&&i>r||setTimeout(s,h,c)},Te=St,[Yt,_e]=me(new Map),ge=P({onLoadingSlow:W,onSuccess:W,onError:W,onErrorRetry:ve,onDiscarded:W,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:Ht?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:Ht?5e3:3e3,compare:Te,isPaused:()=>!1,cache:Yt,mutate:_e,fallback:{}},de),we=(t,e)=>{const n=P(t,e);if(e){const{use:s,fallback:c}=t,{use:r,fallback:i}=e;s&&r&&(n.use=s.concat(r)),c&&i&&(n.fallback=P(c,i))}return n},Oe=w.createContext({}),De="$inf$",Xt=it&&window.__SWR_DEVTOOLS_USE__,Ce=Xt?window.__SWR_DEVTOOLS_USE__:[],ye=()=>{Xt&&(window.__SWR_DEVTOOLS_REACT__=Dt)},Qt=t=>N(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],Ae=()=>P(ge,w.useContext(Oe)),Ve=t=>(e,n,s)=>t(e,n&&((...r)=>{const[i]=yt(e),[,,,h]=U.get(Yt);if(i.startsWith(De))return n(...r);const p=h[i];return u(p)?n(...r):(delete h[i],p)}),s),Ie=Ce.concat(Ve),Le=t=>function(...n){const s=Ae(),[c,r,i]=Qt(n),h=we(s,i);let p=t;const{use:y}=h,v=(y||[]).concat(Ie);for(let a=v.length;a--;)p=v[a](p);return p(c,r||h.fetcher||null,h)},be=(t,e,n)=>{const s=e[t]||(e[t]=[]);return s.push(n),()=>{const c=s.indexOf(n);c>=0&&(s[c]=s[s.length-1],s.pop())}},Fe=(t,e)=>(...n)=>{const[s,c,r]=Qt(n),i=(r.use||[]).concat(e);return t(s,c,{...r,use:i})};ye();const ht=Dt.use||(t=>{switch(t.status){case"pending":throw t;case"fulfilled":return t.value;case"rejected":throw t.reason;default:throw t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t}}),pt={dedupe:!0},Ne=(t,e,n)=>{const{cache:s,compare:c,suspense:r,fallbackData:i,revalidateOnMount:h,revalidateIfStale:p,refreshInterval:y,refreshWhenHidden:v,refreshWhenOffline:a,keepPreviousData:l}=n,[f,C,d,q]=U.get(s),[o,tt]=yt(t),Y=w.useRef(!1),M=w.useRef(!1),_=w.useRef(o),A=w.useRef(e),H=w.useRef(n),m=()=>H.current,$=()=>m().isVisible()&&m().isOnline(),[L,k,j,I]=zt(s,o),z=w.useRef({}).current,et=u(i)?u(n.fallback)?D:n.fallback[o]:i,At=(E,R)=>{for(const g in z){const S=g;if(S==="data"){if(!c(E[S],R[S])&&(!u(E[S])||!c(st,R[S])))return!1}else if(R[S]!==E[S])return!1}return!0},Vt=w.useMemo(()=>{const E=!o||!e?!1:u(h)?m().isPaused()||r?!1:p!==!1:h,R=O=>{const x=P(O);return delete x._k,E?{isValidating:!0,isLoading:!0,...x}:x},g=L(),S=I(),b=R(g),K=g===S?b:R(S);let T=b;return[()=>{const O=R(L());return At(O,T)?(T.data=O.data,T.isLoading=O.isLoading,T.isValidating=O.isValidating,T.error=O.error,T):(T=O,O)},()=>K]},[s,o]),B=ie.useSyncExternalStore(w.useCallback(E=>j(o,(R,g)=>{At(g,R)||E()}),[s,o]),Vt[0],Vt[1]),It=!Y.current,Zt=f[o]&&f[o].length>0,G=B.data,J=u(G)?et&&kt(et)?ht(et):et:G,nt=B.error,Lt=w.useRef(J),st=l?u(G)?Lt.current:G:J,bt=Zt&&!u(nt)?!1:It&&!u(h)?h:m().isPaused()?!1:r?u(J)?!1:p:u(J)||p,Nt=!!(o&&e&&It&&bt),te=u(B.isValidating)?Nt:B.isValidating,ee=u(B.isLoading)?Nt:B.isLoading,X=w.useCallback(async E=>{const R=A.current;if(!o||!R||M.current||m().isPaused())return!1;let g,S,b=!0;const K=E||{},T=!d[o]||!K.dedupe,O=()=>jt?!M.current&&o===_.current&&Y.current:o===_.current,x={isValidating:!1,isLoading:!1},Ft=()=>{k(x)},Ut=()=>{const V=d[o];V&&V[1]===S&&delete d[o]},Mt={isValidating:!0};u(L().data)&&(Mt.isLoading=!0);try{if(T&&(k(Mt),n.loadingTimeout&&u(L().data)&&setTimeout(()=>{b&&O()&&m().onLoadingSlow(o,n)},n.loadingTimeout),d[o]=[R(tt),Ot()]),[g,S]=d[o],g=await g,T&&setTimeout(Ut,n.dedupingInterval),!d[o]||d[o][1]!==S)return T&&O()&&m().onDiscarded(o),!1;x.error=D;const V=C[o];if(!u(V)&&(S<=V[0]||S<=V[1]||V[1]===0))return Ft(),T&&O()&&m().onDiscarded(o),!1;const F=L().data;x.data=c(F,g)?F:g,T&&O()&&m().onSuccess(g,o,n)}catch(V){Ut();const F=m(),{shouldRetryOnError:at}=F;F.isPaused()||(x.error=V,T&&O()&&(F.onError(V,o,F),(at===!0||N(at)&&at(V))&&(!m().revalidateOnFocus||!m().revalidateOnReconnect||$())&&F.onErrorRetry(V,o,F,ne=>{const ct=f[o];ct&&ct[0]&&ct[0](Q.ERROR_REVALIDATE_EVENT,ne)},{retryCount:(K.retryCount||0)+1,dedupe:!0})))}return b=!1,Ft(),!0},[o,s]),xt=w.useCallback((...E)=>Kt(s,_.current,...E),[]);if(dt(()=>{A.current=e,H.current=n,u(G)||(Lt.current=G)}),dt(()=>{if(!o)return;const E=X.bind(D,pt);let R=0;const S=be(o,f,(b,K={})=>{if(b==Q.FOCUS_EVENT){const T=Date.now();m().revalidateOnFocus&&T>R&&$()&&(R=T+m().focusThrottleInterval,E())}else if(b==Q.RECONNECT_EVENT)m().revalidateOnReconnect&&$()&&E();else{if(b==Q.MUTATE_EVENT)return X();if(b==Q.ERROR_REVALIDATE_EVENT)return X(K)}});return M.current=!1,_.current=o,Y.current=!0,k({_k:tt}),bt&&(u(J)||Z?E():Re(E)),()=>{M.current=!0,S()}},[o]),dt(()=>{let E;function R(){const S=N(y)?y(L().data):y;S&&E!==-1&&(E=setTimeout(g,S))}function g(){!L().error&&(v||m().isVisible())&&(a||m().isOnline())?X(pt).then(R):R()}return R(),()=>{E&&(clearTimeout(E),E=-1)}},[y,v,a,o]),w.useDebugValue(st),r&&u(J)&&o){if(!jt&&Z)throw new Error("Fallback data is required when using Suspense in SSR.");A.current=e,H.current=n,M.current=!1;const E=q[o];if(!u(E)){const R=xt(E);ht(R)}if(u(nt)){const R=X(pt);u(st)||(R.status="fulfilled",R.value=!0),ht(R)}else throw nt}return{mutate:xt,get data(){return z.data=!0,st},get error(){return z.error=!0,nt},get isValidating(){return z.isValidating=!0,te},get isLoading(){return z.isLoading=!0,ee}}},Ue=Le(Ne);export{jt as I,D as U,Ae as a,dt as b,Ot as g,P as m,yt as s,Ue as u,Fe as w};
